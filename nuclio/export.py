# Copyright 2018 Iguazio
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
import shlex
from collections import namedtuple
from datetime import datetime
from io import BytesIO, StringIO
from os import path, environ
from textwrap import indent
from zipfile import ZipFile

import yaml
from nbconvert.exporters import Exporter
from nbconvert.filters import ipython2python

from .utils import env_keys, iter_env_lines, parse_config_line, parse_env

here = path.dirname(path.abspath(__file__))

Magic = namedtuple('Magic', 'name is_cell args lines')
magic_handlers = {}  # name -> function

# # nuclio: return
is_return = re.compile(r'#\s*nuclio:\s*return').search
# # nuclio: ignore
has_ignore = re.compile(r'#\s*nuclio:\s*ignore').search
handler_decl = 'def {}(context, event):'
indent_prefix = '    '
missing = object()

function_config = {
    'apiVersion': 'nuclio.io/v1',
    'kind': 'Function',
    'metadata': {},
    'spec': {
        'runtime': 'python:3.6',
        'handler': None,
        'env': [],
    },
    'build': {
        'commands': [],
    }
}

handlers = []


class NuclioExporter(Exporter):
    """Export to nuclio handler"""

    # Add "File -> Download as" menu in the notebook
    export_from_notebook = 'Nuclio'

    output_mimetype = 'application/zip'

    def _file_extension_default(self):
        """Return default file extension"""
        return '.zip'

    def from_notebook_node(self, nb, resources=None, **kw):
        function_config['spec']['handler'] = handler_name()

        io = StringIO()
        print(self.header(), file=io)

        for cell in filter(is_code_cell, nb['cells']):
            code = cell['source']
            if has_ignore(code):
                continue

            magic = parse_magic(code)
            if magic:
                handler = magic_handlers.get(magic.name)
                if not handler:
                    raise NameError(
                        'unknown nuclio command: {}'.format(magic.name))

                out = handler(magic)
                code = out

            print(ipython2python(code), file=io)

        py_code = io.getvalue()
        config = gen_config(function_config)
        zip_data = gen_zip(py_code, config)
        resources['output_extension'] = '.zip'
        return zip_data, resources

    def header(self):
        name = exporter_name()
        return '# Generated by {} on {}\n'.format(name, datetime.now())


def exporter_name():
    return '{}.{}'.format(NuclioExporter.__module__, NuclioExporter.__name__)


def gen_config(config):
    header = '# Generated by {} on {}\n'.format(
        exporter_name(), datetime.now())
    return header + yaml.dump(config, default_flow_style=False)


def parse_magic(code):
    lines = code.strip().splitlines()
    if not lines:
        return None

    magic_line = lines[0]
    prefix = '%nuclio'
    i = magic_line.find(prefix)
    if i == -1:
        return None
    is_cell = '%%nuclio' in magic_line

    args = shlex.split(magic_line[i+len(prefix):])
    cmd, args = args[0], args[1:]

    return Magic(cmd, is_cell, args, lines[1:])


def magic_handler(fn):
    magic_handlers[fn.__name__] = fn
    return fn


def set_env(key, value):
    obj = {
        'name': key,
        'value': value,
    }
    function_config['spec']['env'].append(obj)


@magic_handler
def env(magic):
    for line in [' '.join(magic.args)] + magic.lines:
        line = line.strip()
        if not line or line[0] == '#':
            continue

        key, value = parse_env(line)
        if not key:
            raise ValueError(
                'cannot parse environment value from: {}'.format(line))
        set_env(key, value)
    return ''


@magic_handler
def cmd(magic):
    argline = ' '.join(shlex.quote(arg) for arg in magic.args)
    for line in [argline] + magic.lines:
        line = line.strip()
        if not line or line[0] == '#':
            continue

        line = line.replace('--config-only', '').strip()
        function_config['build']['commands'].append(line)
    return ''


@magic_handler
def env_file(magic):
    for fname in filter(None, map(str.strip, magic.args + magic.lines)):
        with open(fname) as fp:
            for line in iter_env_lines(fp):
                key, value = parse_env(line)
                if not key:
                    raise ValueError(
                        '%s: cannot parse environment: {}'.format(fname, line))
                set_env(key, value)
    return ''


def gen_zip(py_code, config):
    io = BytesIO()
    with ZipFile(io, 'w') as zf:
        with zf.open('handler.py', 'w') as out:
            out.write(py_code.encode('utf-8'))
        with zf.open('function.yaml', 'w') as out:
            out.write(config.encode('utf-8'))

    return io.getvalue()


def is_code_cell(cell):
    return cell['cell_type'] == 'code'


def is_code_line(line):
    """A code line is a non empty line that don't start with #"""
    line = line.strip()
    return line and line[0] not in ('#', '%')


def add_return(line):
    """Add return to a line"""
    match = re.search(r'\w', line)
    if not match:
        # TODO: raise?
        return line

    return line[:match.start()] + 'return ' + line[match.start():]


@magic_handler
def handler(magic):
    name = magic.args[0] if magic.args else next_handler_name()
    if env_keys.handler_name not in environ:
        module, _ = function_config['spec']['handler'].split(':')
        function_config['spec']['handler'] = '{}:{}'.format(module, name)

    code = '\n'.join(magic.lines)
    return handler_code(name, code)


def handler_code(name, code):
    lines = [handler_decl.format(name)]
    code = indent(code, indent_prefix)
    for line in code.splitlines():
        if is_return(line):
            line = add_return(line)
        lines.append(line)

    # Add return to last code line (if not there)
    for i, line in enumerate(lines[::-1]):
        if not is_code_line(line):
            continue

        if 'return' not in line:
            lines[len(lines)-i-1] = add_return(line)
        break

    return '\n'.join(lines)


@magic_handler
def export(magic):
    return ''


@magic_handler
def config(magic):
    for line in [' '.join(magic.args)] + magic.lines:
        key, op, value = parse_config_line(line)
        append = op == '+='
        update_in(function_config, key, value, append)
    return ''


def update_in(obj, key, value, append=False):
    parts = key.split('.')
    for part in parts[:-1]:
        sub = obj.get(part, missing)
        if sub is missing:
            sub = obj[part] = {}
        obj = sub

    last_key = parts[-1]
    if last_key not in obj:
        if append:
            obj[last_key] = []
        else:
            obj[last_key] = {}

    if append:
        obj[last_key].append(value)
    else:
        obj[last_key] = value


def next_handler_name():
    if handlers:
        name = 'handler_{}'.format(len(handlers))
    else:
        name = 'handler'
    handlers.append(name)
    return name


def module_name(py_file):
    """
    >>> module_name('/path/to/handler.py')
    'handler'
    """
    base = path.basename(py_file)
    module, _ = path.splitext(base)
    return module


def handler_name():
    handler_path = environ.get(env_keys.handler_path)
    if handler_path:
        module = module_name(handler_path)
    else:
        module = 'handler'

    name = environ.get(env_keys.handler_name, 'handler')
    return '{}:{}'.format(module, name)
